# HG changeset patch
# User Sajjad Arshad <sarshad@mozilla.com>
# Date 1502397166 25200
#      Thu Aug 10 13:32:46 2017 -0700
# Node ID d93f08514b5b5ce105216b4026b9bceb7d36a70c
# Parent  26a6792f29beed0dad75499f0df6b653dd17240f
Bug 1388925:
Added an opaque flags in the http channel interface by which developer has a fine-grained capability to control TLS configurations.
Basically, all the changes accounted for plumbing this TLS flags from JavaScript level to C++ code responsible for calling NSS module.
We also added a unit test to make sure that separate connections are created if we use different tlsFlags.
Basically we used a concrete set of values that covers the edge cases and check the hashkey generated in the connection info.

diff --git a/netwerk/base/nsISocketTransport.idl b/netwerk/base/nsISocketTransport.idl
--- a/netwerk/base/nsISocketTransport.idl
+++ b/netwerk/base/nsISocketTransport.idl
@@ -238,6 +238,12 @@ interface nsISocketTransport : nsITransp
     const unsigned long BE_CONSERVATIVE = (1 << 7);
 
     /**
+     * opaque flags for non-standard behavior of the TLS system
+     * do not set these unless you are a TLS developer.
+     */
+    attribute unsigned long tlsFlags;
+
+    /**
      * Socket QoS/ToS markings. Valid values are IPTOS_DSCP_AFxx or
      * IPTOS_CLASS_CSx (or IPTOS_DSCP_EF, but currently no supported
      * services require expedited-forwarding).
diff --git a/netwerk/base/nsSocketTransport2.cpp b/netwerk/base/nsSocketTransport2.cpp
--- a/netwerk/base/nsSocketTransport2.cpp
+++ b/netwerk/base/nsSocketTransport2.cpp
@@ -775,6 +775,7 @@ nsSocketTransport::nsSocketTransport()
     , mProxyTransparentResolvesHost(false)
     , mHttpsProxy(false)
     , mConnectionFlags(0)
+    , mTlsFlags(0)
     , mReuseAddrPort(false)
     , mState(STATE_CLOSED)
     , mAttached(false)
@@ -1225,7 +1226,7 @@ nsSocketTransport::BuildSocket(PRFileDes
                                          mHttpsProxy ? mProxyHost.get() : host,
                                          mHttpsProxy ? mProxyPort : port,
                                          proxyInfo, mOriginAttributes,
-                                         controlFlags, &fd,
+                                         controlFlags, mTlsFlags, &fd,
                                          getter_AddRefs(secinfo));
 
                 if (NS_SUCCEEDED(rv) && !fd) {
@@ -1239,7 +1240,7 @@ nsSocketTransport::BuildSocket(PRFileDes
                 // to the stack (such as pushing an io layer)
                 rv = provider->AddToSocket(mNetAddr.raw.family,
                                            host, port, proxyInfo,
-                                           mOriginAttributes, controlFlags, fd,
+                                           mOriginAttributes, controlFlags, mTlsFlags, fd,
                                            getter_AddRefs(secinfo));
             }
 
@@ -2985,6 +2986,20 @@ nsSocketTransport::SetConnectionFlags(ui
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsSocketTransport::GetTlsFlags(uint32_t *value)
+{
+    *value = mTlsFlags;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSocketTransport::SetTlsFlags(uint32_t value)
+{
+    mTlsFlags = value;
+    return NS_OK;
+}
+
 void
 nsSocketTransport::OnKeepaliveEnabledPrefChange(bool aEnabled)
 {
diff --git a/netwerk/base/nsSocketTransport2.h b/netwerk/base/nsSocketTransport2.h
--- a/netwerk/base/nsSocketTransport2.h
+++ b/netwerk/base/nsSocketTransport2.h
@@ -308,6 +308,7 @@ private:
     bool mProxyTransparentResolvesHost;
     bool mHttpsProxy;
     uint32_t     mConnectionFlags;
+    uint32_t     mTlsFlags;
     bool mReuseAddrPort;
 
     // The origin attributes are used to create sockets.  The first party domain
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -128,6 +128,7 @@ struct HttpChannelOpenArgs
   bool                        allowSpdy;
   bool                        allowAltSvc;
   bool                        beConservative;
+  uint32_t                    tlsFlags;
   OptionalLoadInfoArgs        loadInfo;
   OptionalHttpResponseHead    synthesizedResponseHead;
   nsCString                   synthesizedSecurityInfoSerialization;
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -183,6 +183,7 @@ HttpBaseChannel::HttpBaseChannel()
   , mResponseCouldBeSynthesized(false)
   , mBlockAuthPrompt(false)
   , mAllowStaleCacheContent(false)
+  , mTlsFlags(0)
   , mSuspendCount(0)
   , mInitialRwin(0)
   , mProxyResolveFlags(0)
@@ -2614,6 +2615,22 @@ HttpBaseChannel::SetBeConservative(bool 
 }
 
 NS_IMETHODIMP
+HttpBaseChannel::GetTlsFlags(uint32_t *aTlsFlags)
+{
+  NS_ENSURE_ARG_POINTER(aTlsFlags);
+
+  *aTlsFlags = mTlsFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+HttpBaseChannel::SetTlsFlags(uint32_t aTlsFlags)
+{
+  mTlsFlags = aTlsFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 HttpBaseChannel::GetApiRedirectToURI(nsIURI ** aResult)
 {
   NS_ENSURE_ARG_POINTER(aResult);
@@ -3420,6 +3437,8 @@ HttpBaseChannel::SetupReplacementChannel
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     rv = httpInternal->SetBeConservative(mBeConservative);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
+    rv = httpInternal->SetTlsFlags(mTlsFlags);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
 
     RefPtr<nsHttpChannel> realChannel;
     CallQueryInterface(newChannel, realChannel.StartAssignment());
diff --git a/netwerk/protocol/http/HttpBaseChannel.h b/netwerk/protocol/http/HttpBaseChannel.h
--- a/netwerk/protocol/http/HttpBaseChannel.h
+++ b/netwerk/protocol/http/HttpBaseChannel.h
@@ -235,6 +235,8 @@ public:
   NS_IMETHOD SetAllowAltSvc(bool aAllowAltSvc) override;
   NS_IMETHOD GetBeConservative(bool *aBeConservative) override;
   NS_IMETHOD SetBeConservative(bool aBeConservative) override;
+  NS_IMETHOD GetTlsFlags(uint32_t *aTlsFlags) override;
+  NS_IMETHOD SetTlsFlags(uint32_t aTlsFlags) override;
   NS_IMETHOD GetApiRedirectToURI(nsIURI * *aApiRedirectToURI) override;
   virtual MOZ_MUST_USE nsresult AddSecurityMessage(const nsAString &aMessageTag, const nsAString &aMessageCategory);
   NS_IMETHOD TakeAllSecurityMessages(nsCOMArray<nsISecurityConsoleMessage> &aMessages) override;
@@ -541,6 +543,10 @@ protected:
   // Used to enforce that flag's behavior but not expose it externally.
   uint32_t                          mAllowStaleCacheContent : 1;
 
+  // opaque flags for non-standard behavior of the TLS system
+  // do not set these unless you are a TLS developer.
+  uint32_t                          mTlsFlags;
+
   // Current suspension depth for this channel object
   uint32_t                          mSuspendCount;
 
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -2563,6 +2563,7 @@ HttpChannelChild::ContinueAsyncOpen()
   openArgs.allowSpdy() = mAllowSpdy;
   openArgs.allowAltSvc() = mAllowAltSvc;
   openArgs.beConservative() = mBeConservative;
+  openArgs.tlsFlags() = mTlsFlags;
   openArgs.initialRwin() = mInitialRwin;
 
   uint32_t cacheKey = 0;
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -136,7 +136,7 @@ HttpChannelParent::Init(const HttpChanne
                        a.thirdPartyFlags(), a.resumeAt(), a.startPos(),
                        a.entityID(), a.chooseApplicationCache(),
                        a.appCacheClientID(), a.allowSpdy(), a.allowAltSvc(), a.beConservative(),
-                       a.loadInfo(), a.synthesizedResponseHead(),
+                       a.tlsFlags(), a.loadInfo(), a.synthesizedResponseHead(),
                        a.synthesizedSecurityInfoSerialization(),
                        a.cacheKey(), a.requestContextID(), a.preflightArgs(),
                        a.initialRwin(), a.blockAuthPrompt(),
@@ -457,6 +457,7 @@ HttpChannelParent::DoAsyncOpen(  const U
                                  const bool&                allowSpdy,
                                  const bool&                allowAltSvc,
                                  const bool&                beConservative,
+                                 const uint32_t&            tlsFlags,
                                  const OptionalLoadInfoArgs& aLoadInfoArgs,
                                  const OptionalHttpResponseHead& aSynthesizedResponseHead,
                                  const nsCString&           aSecurityInfoSerialization,
@@ -683,6 +684,7 @@ HttpChannelParent::DoAsyncOpen(  const U
   httpChannel->SetAllowSpdy(allowSpdy);
   httpChannel->SetAllowAltSvc(allowAltSvc);
   httpChannel->SetBeConservative(beConservative);
+  httpChannel->SetTlsFlags(tlsFlags);
   httpChannel->SetInitialRwin(aInitialRwin);
   httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
 
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -151,6 +151,7 @@ protected:
               const bool&                allowSpdy,
               const bool&                allowAltSvc,
               const bool&                beConservative,
+              const uint32_t&            tlsFlags,
               const OptionalLoadInfoArgs& aLoadInfoArgs,
               const OptionalHttpResponseHead& aSynthesizedResponseHead,
               const nsCString&           aSecurityInfoSerialization,
diff --git a/netwerk/protocol/http/TunnelUtils.cpp b/netwerk/protocol/http/TunnelUtils.cpp
--- a/netwerk/protocol/http/TunnelUtils.cpp
+++ b/netwerk/protocol/http/TunnelUtils.cpp
@@ -80,7 +80,7 @@ TLSFilterTransaction::TLSFilterTransacti
   if (provider && mFD) {
     mFD->secret = reinterpret_cast<PRFilePrivate *>(this);
     provider->AddToSocket(PR_AF_INET, aTLSHost, aTLSPort, nullptr,
-                          OriginAttributes(), 0, mFD,
+                          OriginAttributes(), 0, 0, mFD,
                           getter_AddRefs(mSecInfo));
   }
 
@@ -1547,6 +1547,8 @@ FWD_TS_ADDREF(GetSecurityCallbacks, nsII
 FWD_TS_PTR(IsAlive, bool);
 FWD_TS_PTR(GetConnectionFlags, uint32_t);
 FWD_TS(SetConnectionFlags, uint32_t);
+FWD_TS_PTR(GetTlsFlags, uint32_t);
+FWD_TS(SetTlsFlags, uint32_t);
 FWD_TS_PTR(GetRecvBufferSize, uint32_t);
 FWD_TS(SetRecvBufferSize, uint32_t);
 
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -498,6 +498,7 @@ nsHttpChannel::Connect()
     mConnectionInfo->SetPrivate(mPrivateBrowsing);
     mConnectionInfo->SetNoSpdy(mCaps & NS_HTTP_DISALLOW_SPDY);
     mConnectionInfo->SetBeConservative((mCaps & NS_HTTP_BE_CONSERVATIVE) || mBeConservative);
+    mConnectionInfo->SetTlsFlags(mTlsFlags);
 
     // Consider opening a TCP connection right away.
     SpeculativeConnect();
diff --git a/netwerk/protocol/http/nsHttpConnectionInfo.cpp b/netwerk/protocol/http/nsHttpConnectionInfo.cpp
--- a/netwerk/protocol/http/nsHttpConnectionInfo.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionInfo.cpp
@@ -92,6 +92,7 @@ nsHttpConnectionInfo::Init(const nsACStr
     mUsingConnect = false;
     mNPNToken = npnToken;
     mOriginAttributes = originAttributes;
+    mTlsFlags = 0x0;
 
     mUsingHttpsProxy = (proxyInfo && proxyInfo->IsHTTPS());
     mUsingHttpProxy = mUsingHttpsProxy || (proxyInfo && proxyInfo->IsHTTP());
@@ -147,7 +148,8 @@ void nsHttpConnectionInfo::BuildHashKey(
     // byte 5 is X/. X is for disallow_spdy flag
     // byte 6 is C/. C is for be Conservative
 
-    mHashKey.AssignLiteral(".......");
+    mHashKey.AssignLiteral(".......[tlsflags0x00000000]");
+
     mHashKey.Append(keyHost);
     if (!mNetworkInterfaceId.IsEmpty()) {
         mHashKey.Append('(');
@@ -259,6 +261,7 @@ nsHttpConnectionInfo::Clone() const
     clone->SetInsecureScheme(GetInsecureScheme());
     clone->SetNoSpdy(GetNoSpdy());
     clone->SetBeConservative(GetBeConservative());
+    clone->SetTlsFlags(GetTlsFlags());
     MOZ_ASSERT(clone->Equals(this));
 
     return clone;
@@ -282,6 +285,7 @@ nsHttpConnectionInfo::CloneAsDirectRoute
     clone->SetInsecureScheme(GetInsecureScheme());
     clone->SetNoSpdy(GetNoSpdy());
     clone->SetBeConservative(GetBeConservative());
+    clone->SetTlsFlags(GetTlsFlags());
     if (!mNetworkInterfaceId.IsEmpty()) {
         clone->SetNetworkInterfaceId(mNetworkInterfaceId);
     }
@@ -310,6 +314,15 @@ nsHttpConnectionInfo::CreateWildCard(nsH
     return NS_OK;
 }
 
+void
+nsHttpConnectionInfo::SetTlsFlags(uint32_t aTlsFlags) {
+    mTlsFlags = aTlsFlags;
+
+    char buf[15];
+    snprintf(buf, sizeof(buf), "%08x", mTlsFlags);
+    mHashKey.Replace(18, 8, buf, 8);
+}
+
 bool
 nsHttpConnectionInfo::UsingProxy()
 {
diff --git a/netwerk/protocol/http/nsHttpConnectionInfo.h b/netwerk/protocol/http/nsHttpConnectionInfo.h
--- a/netwerk/protocol/http/nsHttpConnectionInfo.h
+++ b/netwerk/protocol/http/nsHttpConnectionInfo.h
@@ -122,6 +122,9 @@ public:
                                             { mHashKey.SetCharAt(aBeConservative ? 'C' : '.', 6); }
     bool          GetBeConservative() const { return mHashKey.CharAt(6) == 'C'; }
 
+    void          SetTlsFlags(uint32_t aTlsFlags);
+    uint32_t      GetTlsFlags() const { return mTlsFlags; }
+
     const nsCString &GetNetworkInterfaceId() const { return mNetworkInterfaceId; }
 
     const nsCString &GetNPNToken() { return mNPNToken; }
@@ -176,6 +179,8 @@ private:
     nsCString              mNPNToken;
     OriginAttributes       mOriginAttributes;
 
+    uint32_t               mTlsFlags;
+
 // for RefPtr
     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(nsHttpConnectionInfo)
 };
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -3848,6 +3848,7 @@ nsHalfOpenSocket::SetupStreams(nsISocket
     }
 
     socketTransport->SetConnectionFlags(tmpFlags);
+    socketTransport->SetTlsFlags(ci->GetTlsFlags());
 
     const OriginAttributes& originAttributes = mEnt->mConnInfo->GetOriginAttributes();
     if (originAttributes != OriginAttributes()) {
diff --git a/netwerk/protocol/http/nsIHttpChannelInternal.idl b/netwerk/protocol/http/nsIHttpChannelInternal.idl
--- a/netwerk/protocol/http/nsIHttpChannelInternal.idl
+++ b/netwerk/protocol/http/nsIHttpChannelInternal.idl
@@ -216,6 +216,12 @@ interface nsIHttpChannelInternal : nsISu
      */
     [must_use] attribute boolean beConservative;
 
+    /**
+     * opaque flags for non-standard behavior of the TLS system
+     * do not set these unless you are a TLS developer.
+     */
+    [must_use] attribute unsigned long tlsFlags;
+
     [must_use] readonly attribute PRTime lastModifiedTime;
 
     /**
diff --git a/netwerk/socket/nsISSLSocketControl.idl b/netwerk/socket/nsISSLSocketControl.idl
--- a/netwerk/socket/nsISSLSocketControl.idl
+++ b/netwerk/socket/nsISSLSocketControl.idl
@@ -102,6 +102,11 @@ interface nsISSLSocketControl : nsISuppo
      */
     readonly attribute uint32_t providerFlags;
 
+    /*
+     * The original TLS flags from the socket provider.
+     */
+    readonly attribute uint32_t providerTlsFlags;
+
     /* These values are defined by TLS. */
     const short SSL_VERSION_3   = 0x0300;
     const short TLS_VERSION_1   = 0x0301;
diff --git a/netwerk/socket/nsISocketProvider.idl b/netwerk/socket/nsISocketProvider.idl
--- a/netwerk/socket/nsISocketProvider.idl
+++ b/netwerk/socket/nsISocketProvider.idl
@@ -35,6 +35,9 @@ interface nsISocketProvider : nsISupport
      *        The proxy port for this connection.
      * @param aFlags
      *        Control flags that govern this connection (see below.)
+     * @param aTlsFlags
+     *        opaque flags for non-standard behavior of the TLS system
+     *        do not set these unless you are a TLS developer.
      * @param aFileDesc
      *        The resulting PRFileDesc.
      * @param aSecurityInfo
@@ -48,6 +51,7 @@ interface nsISocketProvider : nsISupport
                    in nsIProxyInfo              aProxy,
                    in const_OriginAttributesRef aOriginAttributes,
                    in unsigned long             aFlags,
+                   in unsigned long             aTlsFlags,
                    out PRFileDescStar           aFileDesc, 
                    out nsISupports              aSecurityInfo);
 
@@ -68,6 +72,7 @@ interface nsISocketProvider : nsISupport
                      in nsIProxyInfo              aProxy,
                      in const_OriginAttributesRef aOriginAttributes,
                      in unsigned long             aFlags,
+                     in unsigned long             aTlsFlags,
                      in PRFileDescStar            aFileDesc, 
                      out nsISupports              aSecurityInfo);
 
diff --git a/netwerk/socket/nsSOCKSIOLayer.cpp b/netwerk/socket/nsSOCKSIOLayer.cpp
--- a/netwerk/socket/nsSOCKSIOLayer.cpp
+++ b/netwerk/socket/nsSOCKSIOLayer.cpp
@@ -78,7 +78,8 @@ public:
               int32_t family,
               nsIProxyInfo *proxy,
               const char *destinationHost,
-              uint32_t flags);
+              uint32_t flags,
+              uint32_t tlsFlags);
 
     void SetConnectTimeout(PRIntervalTime to);
     PRStatus DoHandshake(PRFileDesc *fd, int16_t oflags = -1);
@@ -216,6 +217,7 @@ private:
     int32_t   mVersion;   // SOCKS version 4 or 5
     int32_t   mDestinationFamily;
     uint32_t  mFlags;
+    uint32_t  mTlsFlags;
     NetAddr   mInternalProxyAddr;
     NetAddr   mExternalProxyAddr;
     NetAddr   mDestinationAddr;
@@ -232,6 +234,7 @@ nsSOCKSSocketInfo::nsSOCKSSocketInfo()
     , mVersion(-1)
     , mDestinationFamily(AF_INET)
     , mFlags(0)
+    , mTlsFlags(0)
     , mTimeout(PR_INTERVAL_NO_TIMEOUT)
 {
     mData = new uint8_t[BUFFER_SIZE];
@@ -359,13 +362,14 @@ private:
 
 
 void
-nsSOCKSSocketInfo::Init(int32_t version, int32_t family, nsIProxyInfo *proxy, const char *host, uint32_t flags)
+nsSOCKSSocketInfo::Init(int32_t version, int32_t family, nsIProxyInfo *proxy, const char *host, uint32_t flags, uint32_t tlsFlags)
 {
     mVersion         = version;
     mDestinationFamily = family;
     mProxy           = proxy;
     mDestinationHost = host;
     mFlags           = flags;
+    mTlsFlags        = tlsFlags;
     mProxy->GetUsername(mProxyUsername); // cache
 }
 
@@ -1518,6 +1522,7 @@ nsSOCKSIOLayerAddToSocket(int32_t family
                           nsIProxyInfo *proxy,
                           int32_t socksVersion,
                           uint32_t flags,
+                          uint32_t tlsFlags,
                           PRFileDesc *fd,
                           nsISupports** info)
 {
@@ -1577,7 +1582,7 @@ nsSOCKSIOLayerAddToSocket(int32_t family
     }
 
     NS_ADDREF(infoObject);
-    infoObject->Init(socksVersion, family, proxy, host, flags);
+    infoObject->Init(socksVersion, family, proxy, host, flags, tlsFlags);
     layer->secret = (PRFilePrivate*) infoObject;
 
     PRDescIdentity fdIdentity = PR_GetLayersIdentity(fd);
diff --git a/netwerk/socket/nsSOCKSIOLayer.h b/netwerk/socket/nsSOCKSIOLayer.h
--- a/netwerk/socket/nsSOCKSIOLayer.h
+++ b/netwerk/socket/nsSOCKSIOLayer.h
@@ -17,6 +17,7 @@ nsresult nsSOCKSIOLayerAddToSocket(int32
                                    nsIProxyInfo *proxyInfo,
                                    int32_t       socksVersion,
                                    uint32_t      flags,
+                                   uint32_t      tlsFlags,
                                    PRFileDesc   *fd,
                                    nsISupports **info);
 
diff --git a/netwerk/socket/nsSOCKSSocketProvider.cpp b/netwerk/socket/nsSOCKSSocketProvider.cpp
--- a/netwerk/socket/nsSOCKSSocketProvider.cpp
+++ b/netwerk/socket/nsSOCKSSocketProvider.cpp
@@ -50,6 +50,7 @@ nsSOCKSSocketProvider::NewSocket(int32_t
                                  nsIProxyInfo *proxy,
                                  const OriginAttributes &originAttributes,
                                  uint32_t flags,
+                                 uint32_t tlsFlags,
                                  PRFileDesc **result,
                                  nsISupports **socksInfo)
 {
@@ -75,6 +76,7 @@ nsSOCKSSocketProvider::NewSocket(int32_t
                                             proxy,
                                             mVersion,
                                             flags,
+                                            tlsFlags,
                                             sock,
                                             socksInfo);
     if (NS_SUCCEEDED(rv)) {
@@ -92,6 +94,7 @@ nsSOCKSSocketProvider::AddToSocket(int32
                                    nsIProxyInfo *proxy,
                                    const OriginAttributes &originAttributes,
                                    uint32_t flags,
+                                   uint32_t tlsFlags,
                                    PRFileDesc *sock,
                                    nsISupports **socksInfo)
 {
@@ -101,6 +104,7 @@ nsSOCKSSocketProvider::AddToSocket(int32
                                             proxy,
                                             mVersion,
                                             flags,
+                                            tlsFlags,
                                             sock,
                                             socksInfo);
 
diff --git a/netwerk/socket/nsUDPSocketProvider.cpp b/netwerk/socket/nsUDPSocketProvider.cpp
--- a/netwerk/socket/nsUDPSocketProvider.cpp
+++ b/netwerk/socket/nsUDPSocketProvider.cpp
@@ -21,6 +21,7 @@ nsUDPSocketProvider::NewSocket(int32_t a
                                nsIProxyInfo *aProxy,
                                const OriginAttributes &originAttributes,
                                uint32_t aFlags,
+                               uint32_t aTlsFlags,
                                PRFileDesc * *aFileDesc,
                                nsISupports **aSecurityInfo)
 {
@@ -41,6 +42,7 @@ nsUDPSocketProvider::AddToSocket(int32_t
                                  nsIProxyInfo *aProxy,
                                  const OriginAttributes &originAttributes,
                                  uint32_t aFlags,
+                                 uint32_t aTlsFlags,
                                  struct PRFileDesc * aFileDesc,
                                  nsISupports **aSecurityInfo)
 {
diff --git a/netwerk/test/unit/test_separate_connections.js b/netwerk/test/unit/test_tls_flags_separate_connections.js
copy from netwerk/test/unit/test_separate_connections.js
copy to netwerk/test/unit/test_tls_flags_separate_connections.js
--- a/netwerk/test/unit/test_separate_connections.js
+++ b/netwerk/test/unit/test_tls_flags_separate_connections.js
@@ -7,7 +7,7 @@ XPCOMUtils.defineLazyGetter(this, "URL",
 });
 
 // This unit test ensures each container has its own connection pool.
-// We verify this behavior by opening channels with different userContextId,
+// We verify this behavior by opening channels with different tlsFlags,
 // and their connection info's hash keys should be different.
 
 // In the first round of this test, we record the hash key in each container.
@@ -17,6 +17,8 @@ XPCOMUtils.defineLazyGetter(this, "URL",
 let httpserv = null;
 let gSecondRoundStarted = false;
 
+let randomFlagValues = null;
+
 function handler(metadata, response) {
   response.setHeader("Content-Type", "text/plain", false);
   response.setHeader("Cache-Control", "no-cache", false);
@@ -25,16 +27,18 @@ function handler(metadata, response) {
   response.bodyOutputStream.write(body, body.length);
 }
 
-function makeChan(url, userContextId) {
+function makeChan(url, tlsFlags) {
   let chan = NetUtil.newChannel({ uri: url, loadUsingSystemPrincipal: true });
-  chan.loadInfo.originAttributes = { userContextId: userContextId };
+  chan.QueryInterface(Ci.nsIHttpChannelInternal);
+  chan.tlsFlags = tlsFlags;
+
   return chan;
 }
 
-let previousHashKeys = [];
+let previousHashKeys = {};
 
-function Listener(userContextId) {
-  this.userContextId = userContextId;
+function Listener(tlsFlags) {
+  this.tlsFlags = tlsFlags;
 }
 
 let gTestsRun = 0;
@@ -43,22 +47,22 @@ Listener.prototype = {
     request.QueryInterface(Ci.nsIHttpChannel)
            .QueryInterface(Ci.nsIHttpChannelInternal);
 
-    do_check_eq(request.loadInfo.originAttributes.userContextId, this.userContextId);
+    do_check_eq(request.tlsFlags, this.tlsFlags);
 
     let hashKey = request.connectionInfoHashKey;
     if (gSecondRoundStarted) {
       // Compare the hash keys with the previous set ones.
-      // Hash keys should match if and only if their userContextId are the same.
-      for (let userContextId = 0; userContextId < 3; userContextId++) {
-        if (userContextId == this.userContextId) {
-          do_check_eq(hashKey, previousHashKeys[userContextId]);
+      // Hash keys should match if and only if their tlsFlags are the same.
+      for (let tlsFlags of randomFlagValues) {
+        if (tlsFlags == this.tlsFlags) {
+          do_check_eq(hashKey, previousHashKeys[tlsFlags]);
         } else {
-          do_check_neq(hashKey, previousHashKeys[userContextId]);
+          do_check_neq(hashKey, previousHashKeys[tlsFlags]);
         }
       }
     } else {
       // Set the hash keys in the first round.
-      previousHashKeys[this.userContextId] = hashKey;
+      previousHashKeys[this.tlsFlags] = hashKey;
     }
   },
   onDataAvailable: function(request, ctx, stream, off, cnt) {
@@ -66,7 +70,7 @@ Listener.prototype = {
   },
   onStopRequest: function() {
     gTestsRun++;
-    if (gTestsRun == 3) {
+    if (gTestsRun == randomFlagValues.length) {
       gTestsRun = 0;
       if (gSecondRoundStarted) {
         // The second round finishes.
@@ -81,14 +85,29 @@ Listener.prototype = {
 };
 
 function doTest() {
-  for (let userContextId = 0; userContextId < 3; userContextId++) {
-    let chan = makeChan(URL, userContextId);
-    let listener = new Listener(userContextId);
+  for (let tlsFlags of randomFlagValues) {
+    let chan = makeChan(URL, tlsFlags);
+    let listener = new Listener(tlsFlags);
     chan.asyncOpen2(listener);
   }
 }
 
 function run_test() {
+  // generate 10 random flag values
+  randomFlagValues = new Uint32Array(10);
+
+  for (let i = 0; i < randomFlagValues.length; i++) {
+    let flag_value = 0;
+
+    for (let j = 0; j < 32; j++) {
+      if (Math.random() < 0.5) {
+        flag_value |= (1 << j);
+      }
+    }
+
+    randomFlagValues[i] = flag_value;
+  }
+
   do_test_pending();
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/", handler);
diff --git a/netwerk/test/unit/xpcshell.ini b/netwerk/test/unit/xpcshell.ini
--- a/netwerk/test/unit/xpcshell.ini
+++ b/netwerk/test/unit/xpcshell.ini
@@ -396,3 +396,4 @@ skip-if = os == "android"
 [test_bug1312782_http1.js]
 [test_bug1355539_http1.js]
 [test_bug1378385_http1.js]
+[test_tls_flags_separate_connections.js]
diff --git a/security/manager/ssl/nsNSSIOLayer.cpp b/security/manager/ssl/nsNSSIOLayer.cpp
--- a/security/manager/ssl/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/nsNSSIOLayer.cpp
@@ -75,7 +75,7 @@ getSiteKey(const nsACString& hostName, u
 
 extern LazyLogModule gPIPNSSLog;
 
-nsNSSSocketInfo::nsNSSSocketInfo(SharedSSLState& aState, uint32_t providerFlags)
+nsNSSSocketInfo::nsNSSSocketInfo(SharedSSLState& aState, uint32_t providerFlags, uint32_t providerTlsFlags)
   : mFd(nullptr),
     mCertVerificationState(before_cert_verification),
     mSharedState(aState),
@@ -99,6 +99,7 @@ nsNSSSocketInfo::nsNSSSocketInfo(SharedS
     mMACAlgorithmUsed(nsISSLSocketControl::SSL_MAC_UNKNOWN),
     mBypassAuthentication(false),
     mProviderFlags(providerFlags),
+    mProviderTlsFlags(providerTlsFlags),
     mSocketCreationTimestamp(TimeStamp::Now()),
     mPlaintextBytesRead(0),
     mClientCert(nullptr)
@@ -123,6 +124,13 @@ nsNSSSocketInfo::GetProviderFlags(uint32
 }
 
 NS_IMETHODIMP
+nsNSSSocketInfo::GetProviderTlsFlags(uint32_t* aProviderTlsFlags)
+{
+  *aProviderTlsFlags = mProviderTlsFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsNSSSocketInfo::GetKEAUsed(int16_t* aKea)
 {
   *aKea = mKEAUsed;
@@ -1813,7 +1821,8 @@ nsSSLIOLayerNewSocket(int32_t family,
                       PRFileDesc** fd,
                       nsISupports** info,
                       bool forSTARTTLS,
-                      uint32_t flags)
+                      uint32_t flags,
+                      uint32_t tlsFlags)
 {
 
   PRFileDesc* sock = PR_OpenTCPSocket(family);
@@ -1821,7 +1830,7 @@ nsSSLIOLayerNewSocket(int32_t family,
 
   nsresult rv = nsSSLIOLayerAddToSocket(family, host, port, proxy,
                                         originAttributes, sock, info,
-                                        forSTARTTLS, flags);
+                                        forSTARTTLS, flags, tlsFlags);
   if (NS_FAILED(rv)) {
     PR_Close(sock);
     return rv;
@@ -2425,6 +2434,8 @@ nsSSLIOLayerSetOptions(PRFileDesc* fd, b
     return NS_ERROR_FAILURE;
   }
 
+  // Use infoObject->GetProviderTlsFlags() to get the TLS flags
+
   if ((infoObject->GetProviderFlags() & nsISocketProvider::BE_CONSERVATIVE) &&
       (range.max > SSL_LIBRARY_VERSION_TLS_1_2)) {
     MOZ_LOG(gPIPNSSLog, LogLevel::Debug,
@@ -2522,6 +2533,9 @@ nsSSLIOLayerSetOptions(PRFileDesc* fd, b
   if (flags & nsISocketProvider::BE_CONSERVATIVE) {
     peerId.AppendLiteral("beConservative:");
   }
+
+  peerId.AppendPrintf("tlsflags0x%08x:", infoObject->GetProviderTlsFlags());
+
   peerId.Append(host);
   peerId.Append(':');
   peerId.AppendInt(port);
@@ -2544,7 +2558,8 @@ nsSSLIOLayerAddToSocket(int32_t family,
                         PRFileDesc* fd,
                         nsISupports** info,
                         bool forSTARTTLS,
-                        uint32_t providerFlags)
+                        uint32_t providerFlags,
+                        uint32_t providerTlsFlags)
 {
   nsNSSShutDownPreventionLock locker;
   PRFileDesc* layer = nullptr;
@@ -2554,7 +2569,7 @@ nsSSLIOLayerAddToSocket(int32_t family,
 
   SharedSSLState* sharedState =
     providerFlags & nsISocketProvider::NO_PERMANENT_STORAGE ? PrivateSSLState() : PublicSSLState();
-  nsNSSSocketInfo* infoObject = new nsNSSSocketInfo(*sharedState, providerFlags);
+  nsNSSSocketInfo* infoObject = new nsNSSSocketInfo(*sharedState, providerFlags, providerTlsFlags);
   if (!infoObject) return NS_ERROR_FAILURE;
 
   NS_ADDREF(infoObject);
diff --git a/security/manager/ssl/nsNSSIOLayer.h b/security/manager/ssl/nsNSSIOLayer.h
--- a/security/manager/ssl/nsNSSIOLayer.h
+++ b/security/manager/ssl/nsNSSIOLayer.h
@@ -35,7 +35,7 @@ class nsNSSSocketInfo final : public moz
                               public nsIClientAuthUserDecision
 {
 public:
-  nsNSSSocketInfo(mozilla::psm::SharedSSLState& aState, uint32_t providerFlags);
+  nsNSSSocketInfo(mozilla::psm::SharedSSLState& aState, uint32_t providerFlags, uint32_t providerTlsFlags);
 
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSISSLSOCKETCONTROL
@@ -75,6 +75,7 @@ public:
   void SetSentClientCert() { mSentClientCert = true; }
 
   uint32_t GetProviderFlags() const { return mProviderFlags; }
+  uint32_t GetProviderTlsFlags() const { return mProviderTlsFlags; }
 
   mozilla::psm::SharedSSLState& SharedState();
 
@@ -156,6 +157,7 @@ private:
   bool    mBypassAuthentication;
 
   uint32_t mProviderFlags;
+  uint32_t mProviderTlsFlags;
   mozilla::TimeStamp mSocketCreationTimestamp;
   uint64_t mPlaintextBytesRead;
 
@@ -233,7 +235,8 @@ nsresult nsSSLIOLayerNewSocket(int32_t f
                                PRFileDesc** fd,
                                nsISupports** securityInfo,
                                bool forSTARTTLS,
-                               uint32_t flags);
+                               uint32_t flags,
+                               uint32_t tlsFlags);
 
 nsresult nsSSLIOLayerAddToSocket(int32_t family,
                                  const char* host,
@@ -243,7 +246,8 @@ nsresult nsSSLIOLayerAddToSocket(int32_t
                                  PRFileDesc* fd,
                                  nsISupports** securityInfo,
                                  bool forSTARTTLS,
-                                 uint32_t flags);
+                                 uint32_t flags,
+                                 uint32_t tlsFlags);
 
 nsresult nsSSLIOLayerFreeTLSIntolerantSites();
 nsresult displayUnknownCertErrorAlert(nsNSSSocketInfo* infoObject, int error);
diff --git a/security/manager/ssl/nsSSLSocketProvider.cpp b/security/manager/ssl/nsSSLSocketProvider.cpp
--- a/security/manager/ssl/nsSSLSocketProvider.cpp
+++ b/security/manager/ssl/nsSSLSocketProvider.cpp
@@ -28,6 +28,7 @@ nsSSLSocketProvider::NewSocket(int32_t f
                                nsIProxyInfo *proxy,
                                const OriginAttributes &originAttributes,
                                uint32_t flags,
+                               uint32_t tlsFlags,
                                PRFileDesc **_result,
                                nsISupports **securityInfo)
 {
@@ -39,7 +40,8 @@ nsSSLSocketProvider::NewSocket(int32_t f
                                       _result,
                                       securityInfo,
                                       false,
-                                      flags);
+                                      flags,
+                                      tlsFlags);
   return (NS_FAILED(rv)) ? NS_ERROR_SOCKET_CREATE_FAILED : NS_OK;
 }
 
@@ -51,6 +53,7 @@ nsSSLSocketProvider::AddToSocket(int32_t
                                  nsIProxyInfo *proxy,
                                  const OriginAttributes &originAttributes,
                                  uint32_t flags,
+                                 uint32_t tlsFlags,
                                  PRFileDesc *aSocket,
                                  nsISupports **securityInfo)
 {
@@ -62,7 +65,8 @@ nsSSLSocketProvider::AddToSocket(int32_t
                                         aSocket,
                                         securityInfo,
                                         false,
-                                        flags);
+                                        flags,
+                                        tlsFlags);
 
   return (NS_FAILED(rv)) ? NS_ERROR_SOCKET_CREATE_FAILED : NS_OK;
 }
diff --git a/security/manager/ssl/nsTLSSocketProvider.cpp b/security/manager/ssl/nsTLSSocketProvider.cpp
--- a/security/manager/ssl/nsTLSSocketProvider.cpp
+++ b/security/manager/ssl/nsTLSSocketProvider.cpp
@@ -28,6 +28,7 @@ nsTLSSocketProvider::NewSocket(int32_t f
                                nsIProxyInfo *proxy,
                                const OriginAttributes &originAttributes,
                                uint32_t flags,
+                               uint32_t tlsFlags,
                                PRFileDesc **_result,
                                nsISupports **securityInfo)
 {
@@ -39,7 +40,8 @@ nsTLSSocketProvider::NewSocket(int32_t f
                                       _result,
                                       securityInfo,
                                       true,
-                                      flags);
+                                      flags,
+                                      tlsFlags);
 
   return (NS_FAILED(rv)) ? NS_ERROR_SOCKET_CREATE_FAILED : NS_OK;
 }
@@ -52,6 +54,7 @@ nsTLSSocketProvider::AddToSocket(int32_t
                                  nsIProxyInfo *proxy,
                                  const OriginAttributes &originAttributes,
                                  uint32_t flags,
+                                 uint32_t tlsFlags,
                                  PRFileDesc *aSocket,
                                  nsISupports **securityInfo)
 {
@@ -63,7 +66,8 @@ nsTLSSocketProvider::AddToSocket(int32_t
                                         aSocket,
                                         securityInfo,
                                         true,
-                                        flags);
+                                        flags,
+                                        tlsFlags);
 
   return (NS_FAILED(rv)) ? NS_ERROR_SOCKET_CREATE_FAILED : NS_OK;
 }
