# HG changeset patch
# User Sajjad Arshad <sarshad@mozilla.com>
# Date 1503025729 25200
#      Thu Aug 17 20:08:49 2017 -0700
# Node ID 6cb9850400425f7ddc02e12f931c7fc8e7702724
# Parent  770ed08655c3e760ea6bca170c658751835eaa15
Bug 1391506 - Creating max version, fallback limit, and alt server hello flag values for the tlsFlags

diff --git a/netwerk/socket/nsISocketProvider.idl b/netwerk/socket/nsISocketProvider.idl
--- a/netwerk/socket/nsISocketProvider.idl
+++ b/netwerk/socket/nsISocketProvider.idl
@@ -113,16 +113,41 @@ interface nsISocketProvider : nsISupport
     const unsigned long MITM_OK = 1 << 3;
 
     /**
      * If set, do not use newer protocol features that might have interop problems
      * on the Internet. Intended only for use with critical infra like the updater.
      * default is false.
      */
     const unsigned long BE_CONSERVATIVE = 1 << 4;
+
+    /**
+     * Values for the tlsFlags
+     *
+     * Setting TLS max version
+     */
+    const unsigned long TLS_FLAGS_VERSION_MAX_MASK = (0x7 << 0);
+    const unsigned long TLS_FLAGS_VERSION_MAX_1    = (0x1 << 0);
+    const unsigned long TLS_FLAGS_VERSION_MAX_2    = (0x2 << 0);
+    const unsigned long TLS_FLAGS_VERSION_MAX_3    = (0x3 << 0);
+    const unsigned long TLS_FLAGS_VERSION_MAX_4    = (0x4 << 0);
+
+    /**
+     * Setting TLS fallback limit
+     */
+    const unsigned long TLS_FLAGS_VERSION_FALLBACK_LIMIT_MASK = (0x7 << 3);
+    const unsigned long TLS_FLAGS_VERSION_FALLBACK_LIMIT_1    = (0x1 << 3);
+    const unsigned long TLS_FLAGS_VERSION_FALLBACK_LIMIT_2    = (0x2 << 3);
+    const unsigned long TLS_FLAGS_VERSION_FALLBACK_LIMIT_3    = (0x3 << 3);
+    const unsigned long TLS_FLAGS_VERSION_FALLBACK_LIMIT_4    = (0x4 << 3);
+
+    /**
+     * Enabling Alternative Server Hello
+     */
+    const unsigned long TLS_FLAGS_ALT_SERVER_HELLO = (1 << 6);
 };
 
 %{C++
 /**
  * nsISocketProvider implementations should be registered with XPCOM under a
  * contract ID of the form: "@mozilla.org/network/socket;2?type=foo"
  */
 #define NS_NETWORK_SOCKET_CONTRACTID_PREFIX \
diff --git a/security/manager/ssl/SharedSSLState.cpp b/security/manager/ssl/SharedSSLState.cpp
--- a/security/manager/ssl/SharedSSLState.cpp
+++ b/security/manager/ssl/SharedSSLState.cpp
@@ -112,22 +112,23 @@ PrivateBrowsingObserver::Observe(nsISupp
                                  const char16_t *aData)
 {
   if (!nsCRT::strcmp(aTopic, "last-pb-context-exited")) {
     mOwner->ResetStoredData();
   }
   return NS_OK;
 }
 
-SharedSSLState::SharedSSLState()
+SharedSSLState::SharedSSLState(uint32_t aTlsFlags)
 : mClientAuthRemember(new nsClientAuthRememberService)
 , mMutex("SharedSSLState::mMutex")
 , mSocketCreated(false)
 , mOCSPStaplingEnabled(false)
 , mOCSPMustStapleEnabled(false)
+, mIOLayerHelpers(aTlsFlags)
 {
   mIOLayerHelpers.Init();
   mClientAuthRemember->Init();
 }
 
 SharedSSLState::~SharedSSLState()
 {
 }
diff --git a/security/manager/ssl/SharedSSLState.h b/security/manager/ssl/SharedSSLState.h
--- a/security/manager/ssl/SharedSSLState.h
+++ b/security/manager/ssl/SharedSSLState.h
@@ -14,17 +14,17 @@ class nsClientAuthRememberService;
 class nsIObserver;
 
 namespace mozilla {
 namespace psm {
 
 class SharedSSLState {
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(SharedSSLState)
-  SharedSSLState();
+  SharedSSLState(uint32_t aTlsFlags = 0);
 
   static void GlobalInit();
   static void GlobalCleanup();
 
   nsClientAuthRememberService* GetClientAuthRememberService() {
     return mClientAuthRemember;
   }
 
diff --git a/security/manager/ssl/nsNSSIOLayer.cpp b/security/manager/ssl/nsNSSIOLayer.cpp
--- a/security/manager/ssl/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/nsNSSIOLayer.cpp
@@ -39,16 +39,17 @@
 #include "pkix/pkixtypes.h"
 #include "prmem.h"
 #include "prnetdb.h"
 #include "secder.h"
 #include "secerr.h"
 #include "ssl.h"
 #include "sslerr.h"
 #include "sslproto.h"
+#include "sslexp.h"
 
 using namespace mozilla;
 using namespace mozilla::psm;
 
 //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal
                             //reports when doing SSL read/write
 
 //#define DUMP_BUFFER  //Enable this define along with
@@ -1349,21 +1350,22 @@ nsSSLIOLayerPoll(PRFileDesc* fd, int16_t
   // it reaches any point that would be unsafe to send/receive something before
   // cert validation is complete.
   int16_t result = fd->lower->methods->poll(fd->lower, in_flags, out_flags);
   MOZ_LOG(gPIPNSSLog, LogLevel::Verbose,
           ("[%p] poll SSL socket returned %d\n", (void*) fd, (int) result));
   return result;
 }
 
-nsSSLIOLayerHelpers::nsSSLIOLayerHelpers()
+nsSSLIOLayerHelpers::nsSSLIOLayerHelpers(uint32_t aTlsFlags)
   : mTreatUnsafeNegotiationAsBroken(false)
   , mTLSIntoleranceInfo()
   , mVersionFallbackLimit(SSL_LIBRARY_VERSION_TLS_1_0)
   , mutex("nsSSLIOLayerHelpers.mutex")
+  , mTlsFlags(aTlsFlags)
 {
 }
 
 static int
 _PSM_InvalidInt(void)
 {
   MOZ_ASSERT_UNREACHABLE("I/O method is invalid");
   PR_SetError(PR_INVALID_METHOD_ERROR, 0);
@@ -1674,16 +1676,21 @@ nsSSLIOLayerHelpers::Init()
 }
 
 void
 nsSSLIOLayerHelpers::loadVersionFallbackLimit()
 {
   // see nsNSSComponent::setEnabledTLSVersions for pref handling rules
   uint32_t limit = Preferences::GetUint("security.tls.version.fallback-limit",
                                         3); // 3 = TLS 1.2
+
+  // set fallback limit if it is set in the tls flags
+  if (mTlsFlags & nsISocketProvider::TLS_FLAGS_VERSION_FALLBACK_LIMIT_MASK)
+    limit = (mTlsFlags & nsISocketProvider::TLS_FLAGS_VERSION_FALLBACK_LIMIT_MASK) >> 3;
+
   SSLVersionRange defaults = { SSL_LIBRARY_VERSION_TLS_1_2,
                                SSL_LIBRARY_VERSION_TLS_1_2 };
   SSLVersionRange filledInRange;
   nsNSSComponent::FillTLSVersionRange(filledInRange, limit, limit, defaults);
   if (filledInRange.max < SSL_LIBRARY_VERSION_TLS_1_2) {
     filledInRange.max = SSL_LIBRARY_VERSION_TLS_1_2;
   }
 
@@ -2430,17 +2437,45 @@ nsSSLIOLayerSetOptions(PRFileDesc* fd, b
     }
   }
 
   SSLVersionRange range;
   if (SSL_VersionRangeGet(fd, &range) != SECSuccess) {
     return NS_ERROR_FAILURE;
   }
 
-  // Use infoObject->GetProviderTlsFlags() to get the TLS flags
+  // setting TLS max version
+  switch((infoObject->GetProviderTlsFlags() & nsISocketProvider::TLS_FLAGS_VERSION_MAX_MASK) >> 0) {
+    case 0:
+      // the default value will be used
+      break;
+
+    case 1:
+      range.max = SSL_LIBRARY_VERSION_TLS_1_0;
+      break;
+
+    case 2:
+      range.max = SSL_LIBRARY_VERSION_TLS_1_1;
+      break;
+
+    case 3:
+      range.max = SSL_LIBRARY_VERSION_TLS_1_2;
+      break;
+
+    case 4:
+      range.max = SSL_LIBRARY_VERSION_TLS_1_3;
+      break;
+  }
+  
+  // enabling alternative server hello
+  if (infoObject->GetProviderTlsFlags() & nsISocketProvider::TLS_FLAGS_ALT_SERVER_HELLO) {
+    if (SECSuccess != SSL_UseAltServerHelloType(fd, PR_TRUE)) {
+      return NS_ERROR_FAILURE;
+    }
+  }
 
   if ((infoObject->GetProviderFlags() & nsISocketProvider::BE_CONSERVATIVE) &&
       (range.max > SSL_LIBRARY_VERSION_TLS_1_2)) {
     MOZ_LOG(gPIPNSSLog, LogLevel::Debug,
             ("[%p] nsSSLIOLayerSetOptions: range.max limited to 1.2 due to BE_CONSERVATIVE flag\n",
              fd));
     range.max = SSL_LIBRARY_VERSION_TLS_1_2;
   }
@@ -2563,18 +2598,23 @@ nsSSLIOLayerAddToSocket(int32_t family,
                         uint32_t providerTlsFlags)
 {
   nsNSSShutDownPreventionLock locker;
   PRFileDesc* layer = nullptr;
   PRFileDesc* plaintextLayer = nullptr;
   nsresult rv;
   PRStatus stat;
 
-  SharedSSLState* sharedState =
-    providerFlags & nsISocketProvider::NO_PERMANENT_STORAGE ? PrivateSSLState() : PublicSSLState();
+  SharedSSLState* sharedState = nullptr;
+
+  if (providerTlsFlags)
+    sharedState = new SharedSSLState(providerTlsFlags);
+  else
+    sharedState = (providerFlags & nsISocketProvider::NO_PERMANENT_STORAGE) ? PrivateSSLState() : PublicSSLState();
+
   nsNSSSocketInfo* infoObject = new nsNSSSocketInfo(*sharedState, providerFlags, providerTlsFlags);
   if (!infoObject) return NS_ERROR_FAILURE;
 
   NS_ADDREF(infoObject);
   infoObject->SetForSTARTTLS(forSTARTTLS);
   infoObject->SetHostName(host);
   infoObject->SetPort(port);
   infoObject->SetOriginAttributes(originAttributes);
diff --git a/security/manager/ssl/nsNSSIOLayer.h b/security/manager/ssl/nsNSSIOLayer.h
--- a/security/manager/ssl/nsNSSIOLayer.h
+++ b/security/manager/ssl/nsNSSIOLayer.h
@@ -163,17 +163,17 @@ private:
   uint64_t mPlaintextBytesRead;
 
   nsCOMPtr<nsIX509Cert> mClientCert;
 };
 
 class nsSSLIOLayerHelpers
 {
 public:
-  nsSSLIOLayerHelpers();
+  nsSSLIOLayerHelpers(uint32_t aTlsFlags = 0);
   ~nsSSLIOLayerHelpers();
 
   nsresult Init();
   void Cleanup();
 
   static bool nsSSLIOLayerInitialized;
   static PRDescIdentity nsSSLIOLayerIdentity;
   static PRDescIdentity nsSSLPlaintextLayerIdentity;
@@ -221,16 +221,17 @@ public:
   bool isPublic() const;
   void removeInsecureFallbackSite(const nsACString& hostname, uint16_t port);
   bool isInsecureFallbackSite(const nsACString& hostname);
 
   uint16_t mVersionFallbackLimit;
 private:
   mozilla::Mutex mutex;
   nsCOMPtr<nsIObserver> mPrefObserver;
+  uint32_t mTlsFlags;
 };
 
 nsresult nsSSLIOLayerNewSocket(int32_t family,
                                const char* host,
                                int32_t port,
                                nsIProxyInfo *proxy,
                                const OriginAttributes& originAttributes,
                                PRFileDesc** fd,
diff --git a/security/nss.symbols b/security/nss.symbols
--- a/security/nss.symbols
+++ b/security/nss.symbols
@@ -659,16 +659,17 @@ SSL_ClearSessionCache
 SSL_ConfigSecureServer
 SSL_ConfigSecureServerWithCertChain
 SSL_ConfigServerSessionIDCache
 SSL_ExportKeyingMaterial
 SSL_ForceHandshake
 SSL_GetChannelInfo
 SSL_GetCipherSuiteInfo
 SSL_GetClientAuthDataHook
+SSL_GetExperimentalAPI
 SSL_GetImplementedCiphers
 SSL_GetNextProto
 SSL_GetNumImplementedCiphers
 SSL_GetPreliminaryChannelInfo
 SSL_GetSRTPCipher
 SSL_GetStatistics
 SSL_HandshakeCallback
 SSL_HandshakeNegotiatedExtension
